use std::num::ParseIntError;
use crate::{lexer::{to_tokens, Token}, types::{Node, SequenceNode}};
use crate::lexer::TokenType;
use crate::types::{CallFuncNode, ConstIntNode, ConstStrNode, Int, LambdaNode, Str, VariableNode};

#[derive(Debug)]
pub struct ParserError {
    pub line: u32,
    pub column: u32,
    pub description: String,
}

impl ParserError {
    pub fn new(line: u32, column: u32, description: &str) -> ParserError {
        return ParserError { line, column, description: description.to_string() };
    }
}

pub fn peek(tokens: &Vec<Token>) -> Option<&Token> {
    if tokens.len() == 0 {
        return None;
    }

    tokens.get(tokens.len() - 1)
}

pub fn peek_next(tokens: &Vec<Token>) -> Option<&Token> {
    if tokens.len() < 2 {
        return None;
    }

    tokens.get(tokens.len() - 2)
}

pub fn parse_identifier(tokens: &mut Vec<Token>) -> Result<String, ParserError> {
    let next_token_result: Option<&Token> = peek(tokens);

    if next_token_result.is_none() {
        return Err(ParserError::new(1, 1, "Expected identifier, but found end of file"));
    }

    let next_token: Token = tokens.pop().unwrap();

    if next_token.token_type != TokenType::Identifier {
        return Err(ParserError::new(next_token.line, next_token.column, &format!("Expected identifier, but found {:?}", next_token.token_type)));
    }

    Ok(next_token.content)
}

pub fn parse_expression(tokens: &mut Vec<Token>) -> Option<Result<&mut dyn Node, ParserError>> {
    let next_token_result: Option<&Token> = peek(tokens);

    if next_token_result.is_none() {
        return Some(Err(ParserError::new(0, 0, "Expected right parentheses (')'), but found end of file")));
    }

    let next_token: &Token = next_token_result.unwrap();

    if next_token.token_type == TokenType::Rparen {
        tokens.pop();
        return None;
    }

    if next_token.token_type == TokenType::Identifier {
        let next_token2_result: Option<&Token> = peek_next(tokens);

        if next_token2_result.is_none() {
            return Some(Err(ParserError::new(0, 0, "Expected right parentheses (')'), but found end of file")));
        }

        let next_token2: &Token = next_token2_result.unwrap();

        if next_token2.token_type == TokenType::Lparen {
            let result = parse_function(tokens);

            if result.is_err() {
                return Some(Err(result.err().unwrap()));
            }

            return Some(Ok(result.unwrap()));
        }

        return Some(Ok(&mut VariableNode::new(&tokens.pop().unwrap().content)));
    }

    if next_token.token_type == TokenType::Number {
        let line = next_token.line;
        let column = next_token.column;
        let parse_result: Result<i64, ParseIntError> = tokens.pop().unwrap().content.parse::<i64>();

        if parse_result.is_err() {
            return Some(Err(ParserError::new(line, column, "Invalid integer")));
        }

        return Some(Ok(&mut ConstIntNode::new(Int::new(parse_result.unwrap()))));
    }

    if next_token.token_type == TokenType::String {
        return Some(Ok(&mut ConstStrNode::new(Str::new(&tokens.pop().unwrap().content))));
    }

    if next_token.token_type == TokenType::Lbrace {
        let parse_result = parse_sequence(tokens, false);

        if parse_result.is_err() {
            return Some(Err(parse_result.unwrap_err()))
        }

        return Some(Ok(&mut parse_result.unwrap()));
    }

    Some(Err(ParserError::new(next_token.line, next_token.column, &format!("Expected expression, but found {:?}", next_token.token_type))))
}

pub fn parse_arguments(tokens: &mut Vec<Token>) -> Result<Vec<&mut dyn Node>, ParserError> {
    let mut seq: Vec<&mut dyn Node> = Vec::new();
    let next_token_result: Option<&Token> = peek(tokens);

    if next_token_result.is_none() {
        return Err(ParserError::new(0, 0, "Expected left parentheses ('('), but found end of file"));
    }

    let next_token: &Token = next_token_result.unwrap();

    if next_token.token_type != TokenType::Lparen {
        return Err(ParserError::new(next_token.line, next_token.column, &format!("Expected left parentheses ('('), but found {:?}", next_token.token_type)));
    }

    tokens.pop();

    let after_token_result: Option<&Token> = peek(tokens);

    if after_token_result.is_none() {
        return Err(ParserError::new(0, 0, "Expected right parentheses (')'), but found end of file"))
    }

    if after_token_result.unwrap().token_type == TokenType::Rparen {
        tokens.pop();
        return Ok(seq);
    }

    let mut expr_result_option: Option<Result<&mut dyn Node, ParserError>> = parse_expression(tokens);

    while expr_result_option.is_some() {
        if expect_comma(tokens).is_none() {
            if peek(tokens).is_none() {
                return Err(ParserError::new(0, 0, "Expected right parentheses (')'), but found end of file"));
            }

            let token = peek(tokens).unwrap();

            if token.token_type == TokenType::Rparen {
                break;
            }

            return Err(ParserError::new(token.line, token.column, &format!("Expected right parentheses (')'), but found {:?}", token.token_type)))
        }

        let expr_result: Result<&mut dyn Node, ParserError> = expr_result_option.unwrap();

        if expr_result.is_err() {
            return Err(expr_result.err().unwrap());
        }

        let mut expr: &mut dyn Node = expr_result.unwrap();
        seq.push(expr);

        expr_result_option = parse_expression(tokens);
    }

    let token_result = peek(tokens);

    if token_result.is_none() {
        return Err(ParserError::new(0, 0, "Expected right parentheses (')'), but found end of file"));
    }

    let token = token_result.unwrap();

    if token.token_type != TokenType::Rparen {
        return Err(ParserError::new(token.line, token.column, &format!("Expected right parentheses (')'), but found {:?}", token.token_type)));
    }

    tokens.pop().unwrap().token_type; // Rparen
    return Ok(seq);
}

pub fn parse_function(tokens: &mut Vec<Token>) -> Result<&mut dyn Node, ParserError> {
    let func_name: Result<String, ParserError> = parse_identifier(tokens);

    if func_name.is_err() {
        return Err(func_name.unwrap_err());
    }

    let func_args: Result<Vec<&mut dyn Node>, ParserError> = parse_arguments(tokens);

    if func_args.is_err() {
        return Err(func_args.err().unwrap());
    }

    Ok(&mut CallFuncNode::new(func_name.unwrap(), func_args.unwrap()))
}

pub fn expect_comma(tokens: &mut Vec<Token>) -> Option<Token> {
    let next_token: Option<&Token> = peek(tokens);

    if next_token.is_none() {
        return None;
    }

    if next_token.unwrap().token_type != TokenType::Comma {
        return None;
    }

    Some(tokens.pop().unwrap())
}

pub fn parse_sequence(tokens: &mut Vec<Token>, toplevel: bool) -> Result<SequenceNode, ParserError> {
    let mut seq: Vec<*mut Node> = Vec::new();
    println!("PSEQ: {}", toplevel);

    if !toplevel {
        let next_token_result: Option<&Token> = peek(tokens);

        if next_token_result.is_none() {
            return Err(ParserError::new(0, 0, "Expected left brace ('{'), but found end of file"));
        }

        let next_token: &Token = next_token_result.unwrap();

        if next_token.token_type != TokenType::Lbrace {
            return Err(ParserError::new(next_token.line, next_token.column, &format!("Expected left brace ('{{'), but found {:?}", next_token.token_type)));
        }

        tokens.pop();
    }

    if toplevel {
        let next_token_result: Option<&Token> = peek(tokens);

        if next_token_result.is_none() {
            return Ok(SequenceNode::new(seq));
        }
    } else {
        println!("B1");
        let next_token_result: Option<&Token> = peek(tokens);

        if next_token_result.is_none() {
            return Err(ParserError::new(0, 0, "Expected right brace ('}'), but found end of file"));
        }

        let next_token: &Token = next_token_result.unwrap();

        if next_token.token_type == TokenType::Rbrace {
            tokens.pop();
            println!("RET 1");
            return Ok(SequenceNode::new(seq));
        }
    }

    let call_func: Result<*mut CallFuncNode, ParserError> = parse_function(tokens);

    if call_func.is_err() {
        println!("RET 6");
        return Err(call_func.unwrap_err());
    }

    seq.push(call_func.unwrap() as *mut Node);

    while (toplevel && peek(tokens).is_some()) || (!toplevel && peek(tokens).is_some() && peek(tokens).unwrap().token_type != TokenType::Rbrace) {
        let next_token: Option<&Token> = peek(tokens);
        println!("ITER");

        if next_token.is_none() {
            if !toplevel {
                return Err(ParserError::new(0, 0, "Expected right brace ('}'), but found end of file"));
            }

            return Ok(SequenceNode::new(seq));
        }

        let token = next_token.unwrap();

        if token.token_type == TokenType::Rbrace {
            if toplevel {
                return Err(ParserError::new(0, 0, "Unexpected right brace ('}')"));
            }

            tokens.pop();
            println!("RET 2");
            return Ok(SequenceNode::new(seq));
        }

        if token.token_type == TokenType::Comma {
            tokens.pop();
        }

        let func_result: Result<*mut CallFuncNode, ParserError> = parse_function(tokens);

        if func_result.is_err() {
            println!("RET 5");
            return Err(func_result.unwrap_err());
        }

        seq.push(func_result.unwrap() as *mut Node);
    }

    if !toplevel {
        tokens.pop();
    }

    println!("RET 3");
    return Ok(SequenceNode::new(seq));
}

pub fn parse_tokens(tokens: &mut Vec<Token>) -> Result<SequenceNode, ParserError> {
    /*
    # Syntax:
    START [Identifier=Id,Lparen=Lp,Rparen=Rp,Lbrace=Lb,Rbrace=Rb,Id Lp=Fc,IntConstant=Ic,StringConstant=Sc,Comma=Cm] END = SequenceNode(vec![Split(Cm, $)])
    Fc [Id=ID,Ic=IC,Sc=SC,Cm=CM,Fc..Rp=OF,Lb..Rb=FB]* Rp = CallFuncNode(Fc.Id.value, vec![Split(CM, Fc.Lp..Rp)])
        ID = GetVariableNode(ID.name)
        IC = IntConstant(IC.value)
        SC = StrConstant(SC.value)
        OF = CallFuncNode(OF.Fc.Id.name, vec![Split(CM, OF.Fc..OF.Rp)])
        FB = LambdaNode(FB.Lb..FB.Rb)
    ELSE = ParserError(...)
    # End of syntax

    # Code:
    declvar("i", "a", 5),
    declvar("i", "b", parse_int(input()))
    print(add(a, b))
    # End of code

    # Pseudo-code implementation:
    fn parse_sequence() {
        seq=vec![]
        seq.push(parse_function())
        while (expect_comma().is_some()) {
            seq.push(parse_function())
        }
        return seq;
    }
    
    fn expect_*(tokens, *=a) {
        if peek(tokens).type != a {
            return None;
        }

        return Some(tokens.pop())
    }
    
    get_identifier = expect_identifier;
    
    fn get_arguments() {
        args=vec![]
        args.push(parse_expression_or_rparen())
        while (expect_comma().is_some()) {
            args.push(parse_expression_or_rparen());
        }
        return args;
    }
    
    fn parse_expression_or_rparen(tokens) {
        let token = peek(tokens);

        if token.type == Ident&&peek_next(tokens).type==Lparen {
            return parse_function(tokens);
        } else if token.type==Ident {
            return parse_identifier(tokens);
        } else if token.type==Str {
            return parse_str(tokens);
        } else if token.type == Int {
            return parse_int(tokens);
        } else {
            return ParserError(...);
        }
    }

    fn parse_function {
        return CallFuncNode(get_identifier(), get_arguments());
    }

    parse_* = todo!();
    # End of pseudo-code implementation

    # Result
    parse_sequence(##TOPLEVEL##) {
        parse_function {
            get_identifier() = "declvar";
            get_arguments() {
                expect_lparen();
                parse_expression_or_rparen() = Str("i");
                expect_comma();
                parse_expression_or_rparen() = Str("a");
                expect_comma();
                parse_expression_or_rparen() = Int(5);
                expect_comma() = None => args = vec![Str("i"), Str("a"), Int(5)];
                expect_rparen();
                return args;
            } = vec![Str("i"), Str("a"), Int(5)];
            return all;
        } = CallFuncNode("declvar", vec![Str("i"), Str("a"), Int(5)]);
        expect_comma();
        parse_function {
            get_identifier() = "declvar";
            get_arguments() {
                expect_lparen();
                parse_expression_or_rparen() = Str("i");
                expect_comma();
                parse_expression_or_rparen() = Str("b");
                expect_comma();
                parse_expression_or_rparen() = parse_function {
                    get_identifier() = "parse_int";
                    get_arguments() {
                        expect_lparen();
                        parse_expression_or_rparen() = parse_function {
                            get_identifier() = "input";
                            get_arguments() {
                                expect_lparen();
                                parse_expression_or_rparen() = None;
                                expect_rparen();
                                return vec![];
                            } = vec![];
                        } = CallFuncNode("input", vec![]);
                    } = vec![CallFuncNode("input", vec![])];
                } = CallFuncNode("parse_int", vec![CallFuncNode("input", vec![])]);
                expect_comma() = None => args = vec![Str("i"), Str("b"), CallFuncNode("parse_int", vec![CallFuncNode("input", vec![])])];
                expect_rparen();
                return args;
            } = vec![Str("i"), Str("b"), CallFuncNode("parse_int", vec![CallFuncNode("input", vec![])])];
            return all;
        } = CallFuncNode("declvar", vec![Str("i"), Str("b"), CallFuncNode("parse_int", vec![CallFuncNode("input", vec![])])]);
        expect_comma();
        parse_function {
            get_identifier() = "print";
            get_arguments() {
                expect_lparen();
                parse_expression_or_rparen() = parse_function {
                    get_identifier() = "add";
                    get_arguments() {
                        expect_lparen();
                        parse_expression_or_rparen() = VarNode("a");
                        expect_comma();
                        parse_expression_or_rparen() = VarNode("b");
                        expect_comma() = None => args = vec![VarNode("a"), VarNode("b")];
                        return args;
                    } = vec![CallFuncNode("add", vec![VarNode("a"), VarNode("b")])];
                } = CallFuncNode("print", vec![CallFuncNode("add", vec![VarNode("a"), VarNode("b")])]);
                expect_comma() = None => expect_rparen(); args = vec![CallFuncNode("add", vec![VarNode("a"), VarNode("b")])];
                return args;
            } = vec![CallFuncNode("add", vec![VarNode("a"), VarNode("b")])];
            return all;
        } = CallFuncNode("print", vec![CallFuncNode("add", vec![VarNode("a"), VarNode("b")])]);
        expect_comma() = None;
    } = SequenceNode(CallFuncNode("declvar", vec![Str("i"), Str("a"), Int(5)]), CallFuncNode("declvar", vec![Str("i"), Str("b"), CallFuncNode("parse_int", vec![CallFuncNode("input", vec![])])]), CallFuncNode("print", vec![CallFuncNode("add", vec![VarNode("a"), VarNode("b")])]));
    # End of result
     */
    parse_sequence(tokens, true)
}

pub fn parse(code: &str) -> Result<SequenceNode, ParserError> {
    let tokens_result = to_tokens(code);

    if tokens_result.is_err() {
        let error = tokens_result.unwrap_err();
        return Err(ParserError { line: error.line, column: error.column, description: error.description });
    }

    let mut tokens = tokens_result.unwrap();
    parse_tokens(&mut tokens)
}

pub unsafe fn print_call_func_node(node: CallFuncNode) {
    print!("Function(\"{}\", ", node.name);
    let mut i = 0;
    let len = node.args.len();

    for arg in node.args {
        let node_type = (*arg).node_type;
        match node_type {
            0 => print_ast((*(arg as *mut SequenceNode)).clone()),
            1 => print_call_func_node((*(arg as *mut CallFuncNode)).clone()),
            2 => print_const_int_node((*(arg as *mut ConstIntNode)).clone()),
            3 => print_const_str_node((*(arg as *mut ConstStrNode)).clone()),
            4 => print_variable_node((*(arg as *mut VariableNode)).clone()),
            5 => print_lambda_node((*(arg as *mut LambdaNode)).clone()),
            _ => unimplemented!()
        };

        i += 1;

        if len == i {
            break;
        }

        print!(", ");
    }

    print!(")");
}

pub fn print_const_int_node(node: ConstIntNode) {
    print!("Int({})", node.value.number);
}

pub fn print_const_str_node(node: ConstStrNode) {
    print!("Str({})", node.value.text);
}

pub fn print_variable_node(node: VariableNode) {
    print!("Variable({})", node.name);
}

pub unsafe fn print_lambda_node(node: LambdaNode) {
    print!("Lambda(");
    _print_ast(node.body);
    print!(")");
}

pub unsafe fn _print_ast(ast: SequenceNode) {
    let mut i = 0;
    let len = ast.body.len();

    for node in ast.body {
        let node_type = (*node).node_type;
        println!("NODEIS!!!:{}", node_type);
        match node_type {
            0 => _print_ast((*(node as *mut SequenceNode)).clone()),
            1 => print_call_func_node((*(node as *mut CallFuncNode)).clone()),
            2 => print_const_int_node((*(node as *mut ConstIntNode)).clone()),
            3 => print_const_str_node((*(node as *mut ConstStrNode)).clone()),
            4 => print_variable_node((*(node as *mut VariableNode)).clone()),
            5 => print_lambda_node((*(node as *mut LambdaNode)).clone()),
            _ => unimplemented!()
        };

        i += 1;

        if len == i {
            break;
        }

        print!(", ");
    }

    print!(")");
}

/// Prints Abstract Syntax Tree, given by parser.
///
/// # Safety
/// Abstract Syntax Tree must be returned from this parser, or at least be valid:
/// 1. All pointers must point to valid nodes with valid types
pub unsafe fn print_ast(ast: SequenceNode) {
    print!("Sequence(");
    _print_ast(ast);
    print!(")");
}
